---
title: 03.线程模型
date: 2025-06-17 15:37:58
author: Navyum
icon: devicon-plain:redis
tags: 
 - Redis
 - 线程模型
categories: 
 - Redis
article: true
index: true

headerDepth: 2
sticky: false
star: true
---


### 误解：redis只有一个线程
* Redis 的`网络IO`和`键值对读写`是由一个线程（主线程）来完成的（Redis6.0 网络IO改为多线程模型）
* Redis的其他功能，比如`持久化`、`异步删除`、`集群数据同步`等，其实是由额外的线程执行的。

### 为什么用单线程：
1. 多线程开销问题
2. 多线程并发竞争问题，需要引入同步原语或者锁机制（主要是一些写操作）
（此处没有很好解释原因，而是用多线程缺点来阐述，不够严谨）

### 为什么用单线程还这么快：
1. 大部分操作在内存
2. 使用了IO多路复用（Redis6.0之后采用`多线程模型`处理网络IO请求）

### redis常见的性能瓶颈问题：
1. 请求耗时严重时，会影响整个server的性能。例如：
	- `操作bigkey`：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时
	- `使用复杂度过高的命令`：例如一次查询全量数据；
	- `大量key集中过期`：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；
	- `淘汰策略`：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
	- `AOF刷盘开启always机制`：每次写入都需要把这个操作刷到磁盘。写磁盘的速度远比写内存慢，会拖慢Redis的性能；
	- `主从全量同步生成RDB`：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大阻塞时间越久；

2. 并发请求量非常大时，单线程读写客户端IO数据存在性能瓶颈
    - 虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

### 瓶颈问题解决方案：
* 针对问题1：
    * 通过业务人员规避
    * Redis4.0 推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

* 针对问题2：
    * Redis6.0 推出了多线程网络IO模型，可以在高并发场景下利用CPU多核多线程读写客户端数据。但只针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。

