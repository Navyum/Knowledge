---
title: 07.持久化-RDB
date: 2025-06-17 15:38:19
author: Navyum
icon: devicon-plain:redis
tags: 
 - Redis
 - 持久化
 - RDB
categories: 
 - Redis
article: true
index: true

headerDepth: 2
sticky: false
star: true
---


### RDB（Redis DataBase）：
* 含义：RDB 快照就是记录Redis`某一个瞬间的全部内存数据`，记录的是实际数据。这个文件就是RDB快照文件。

### 跟AOF对比：
* 文件内容：
    * RDB 文件的内容是二进制数据（状态数据）
    * AOF文件内容是命令数据（操作数据）
* 数据恢复效率：
    * RDB 文件直接读入内存完成恢复，效率更高
    * AOF 需要执行操作命令，通过逐个重放命令实现恢复，效率低
* 执行的进程：
    * RDB 是在bgsave子进程，因为RDB需要对全量数据做写入，不能在主进程做
    * AOF 是在主进程，因为AOF每次只有少量命令，并且是追加写（顺序写），在主进程影响不大

### RDB的特性：
- `当前时刻`的`全量`数据做`快照`，所以需要控制好频率
- 生成RDB文件的命令：
    - `save`在主进程进行，会阻塞主进程
    - `bgsave`创建`子进程`，不易阻塞主进程
- RDB 文件加载工作：
    - 服务器启动时`自动执行加载`
- 通过`写时复制COW`（copy on write），做快照时，不阻塞主进程的修改操作。
- 当前RDB过程中，增量数据无法在当前周期进行备份，需要等到下一次RDB。RDB保存的是fork子进程那个时刻的数据快照
- 缺点：
    - 快照频率太低：两次快照期间如果宕机，则只能恢复到最近一次快照的数据，期间的数据都会丢失
    - 快照频率太高：频繁fork子进程和全量写磁盘，影响性能

### RDB 完整过程：
![Img](https://raw.staticdn.net/Navyum/imgbed/pic/IMG/55ab892415260f6ef29f765a0f98eccb.png)

1. bgsave fork出子进程，子进程享有主进程的物理内存数据
2. 子进程进行内存数据写磁盘操作
3. 期间如果主进程发生数据修改，如键值对C，那么会触发`写时复制`，生成该数据的副本（键值对 C’），主线程在这个数据副本上进行修改。
4. bgsave 子进程不受影响，继续把原来的数据写入 RDB 文件

### 混合持久化：
* `发生时机`：
    * `AOF 日志重写`发生时
* `aof-use-rdb-preamble`配置：
    * yes 开启
* 特点：结合了RDB的恢复速度和AOF的数据丢失少

### 混合持久化过程：
1. 当`AOF 重写日志`发生时：
2. 主进程fork 出重写子进程`bgrewriteaof`
3. 子进程先将与主进程共享的内存数据以 `RDB 方式`写入到`新的AOF 文件`
4. 期间，主线程处理的`增量写命令`会被记录在`AOF 重写缓冲区`
5. 当`RDB方式`完成后，`AOF 重写缓冲区`的数据会以`AOF格式`，追加写入到这个新的AOF文件后面
6. `AOF 重写缓冲区`的数据全部写入完成后，通知主进程进行新、旧AOF文件替换

### 混合持久化文件格式：
- 前半部分为RDB格式
- 后半部分为AOF格式
![Img](https://raw.staticdn.net/Navyum/imgbed/pic/IMG/742cb8891521a0ade89436926e7fa235.png)

### 持久化的选择：
1. 数据`不能丢失`时，内存快照`RDB`和`AOF`的混合使用是一个很好的选择
2. 如果允许`分钟级别的数据丢失`，可以只使用RDB
3. 其他场景建议使用`AOF`。
    * 使用AOF做持久化，刷盘策略优先使用 `everysec` 的配置选项，因为它在可靠性和性能之间取了一个平衡
