1. HTTP
    1. 发送格式：![图片](./IMG/8.%20应用层（七层）.md/2b1e9ffb.png)

    2. 响应格式：
![图片](./IMG/8.%20应用层（七层）.md/222d0ea5.png)


2. HTTPS
    SSL/TLS 握手协议

3. HTTP 2.0
帧协议：![图片](./IMG/8.%20应用层（七层）.md/075d9fbc.png)

帧长度：控制单个帧最大2^24 = 16M

帧类型: 大致可以分成数据帧（HEADERS 、DATA）和控制帧（SETTINGS、PING、PRIORITY）。此外 gRPC 定义了几种自用的新帧类型。

帧标志：8 个标志位。END_HEADERS（\r\n）、END_STREAM（0\r\n\r\n）PRIORITY（是否设置优先级）、GOAWAY（流ID用完时关闭tcp连接）、RST_STREAM(异常终止)

流标识符: 即stream ID


    1. header中 h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2
    2. HTTP2.0 优化：
        1. 头部压缩：HPACK算法，双端建立头部索引表，通过索引交互
        2. **多路复用：在一个 TCP 的连接中，用一个流来进行一次请求-响应，多个流之间可以并发。**
        3. 采用二进制格式编码（HTTP 1.1 ASCII）。化整为零将传输信息（header+body）分割为更小的消息和帧。
            1. Header 帧：用于传输 Header 内容
            2. Data 帧，用来传输正文实体（多个 Data 帧属于同一个流，有先后顺序）
        4. 服务器推送（Server Push，也叫 Cache Push），将可能会用到的数据发送给客户端 (服务器推送实际上就是对一个未曾发出的客户端请求做出响应)
        5. 解决http的队头阻塞问题（http1请求需要排队，http2流可以并发），但没有解决tcp的队头阻塞问题（发生丢包时依赖tcp重传，得等到收到数据后才能继续处理后续流）

    3. 流的特性：
        1. 流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；
        2. 客户端和服务器都可以创建流，双方互不干扰；
        3. 流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；1个流对应一次http请求、响应
        4. 流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；
        5. 流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；
        6. 流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；
        7. 在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；
        8. 第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。
    4. 数据收发：
        1. 在“流”的层面上看，消息是一些有序的“帧”序列（流是逻辑层面的概念）
        2. 在“连接”的层面上看，消息却是乱序收发的“帧”。
            1. 多个请求 / 响应之间没有了顺序关系，不需要根据请求顺序排队等待，从而解决“队头阻塞”问题。降低了延迟，大幅度提高了连接的利用率。
![图片](./IMG/8.%20应用层（七层）.md/37dc269a.png)

    5. 具体发送过程：
        1. 发送方将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。
        2. 这些帧可以打散乱序发送， 接收方根据每个帧首部的流标识符重新组装。
        3. 可以根据优先级，决定优先处理哪个流的数据
    6. 发送示意图：
1.1 vs  2.0
![图片](./IMG/8.%20应用层（七层）.md/2c7c09e7.png)

![图片](./IMG/8.%20应用层（七层）.md/b2229caa.png)


4. QUIC
    1. 解决HTTP2的问题：
        1. tcp队头阻塞：quic的流基于UDP连接，每个流相互独立，互不影响
        2. TCP 建立连接的延迟（tcp+tls 1RTT +2 RTT）tls在应用层握手
        3. 网络迁移需要重新建立 TCP 连接（tcp 五元组，quic 使用唯一的connection id）
    2. 机制：
        1. 自定义连接机制：不再以五元组标识，而是以一个 64 位的随机数作为 ID 来标识
        2. 自定义重传机制：QUIC 也有个序列号，是递增的，每次ACK是对对应序号确认接受到。每个数据包有offset，用来确认在数据流中的位置。
![图片](./IMG/8.%20应用层（七层）.md/4abfcb10.png)

        3. 无阻塞的多路复用：
同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。前面的stream丢包，后面的stream无需等待
        4. 自定义流量控制：
            1. QUIC 通过 window_update来告诉对端它可以接受的字节数
            2. QUIC 窗口的起始位置为当前收到的最大 offset
            3. QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答（相信中间的空档一定会到来）
            4. 示意图：tcp 和 quic![图片](./IMG/8.%20应用层（七层）.md/f0e09620.png)

对比:
![图片](./IMG/8.%20应用层（七层）.md/ce94a3ad.png)
            5. 



[https://http3-explained.haxx.se/zh/why-quic/why-tcphol](https://http3-explained.haxx.se/zh/why-quic/why-tcphol)

[https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93](https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93)

