# 熔断设计-Circuit-Breaker

含义：

    类比电路中的保险丝。熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定是继续操作，还是立即返回错误。

注意点：

*     当重试无法解决问题，即故障不是暂时的。使用熔断可以保护后端业务不会过载。
*     避免资源浪费，防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。
*     熔断器模式基本功能：诊断服务是否出现长时间故障，自动熔断。诊断错误是否已经修正，自动恢复服务。
熔断器模式使用状态机：

   闭合状态（closed）

   我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在 Closed 状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。

   断开状态（open）

   在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。有时可以 cache 住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。

   半开状态（half-open）

    允许应用程序一定数量的请求去调用服务。

    如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。

    如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开状态，然后重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。

![图片](https://raw.staticdn.net/Navyum/imgbed/pic/IMG/eafa00da9398ae15de780601b0fd6a6a.png)


最佳实践：hystrix  地址：[https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix)


熔断设计重点：

* 错误的类型。
* 日志监控
* 测试服务可用，可以使用熔断器主动检测方式，而不是用户请求惰性检测。
* 手动重置。例如恢复时间无法确定的时候。
* 熔断器可支持的并发量。对统计的数据结构，设计成无锁结构，或者支持atomic原子操作。
* 对资源分区问题，只在易错分区或者故障分区上进行设计和熔断，而不是整体全部熔断。
* 半开状态下，自主重试错误请求以校验服务是否恢复。



