# 基本概念：

容错： 代表了在异常情况下仍然具有可用性和正确性。（前提是大部分节点正常）

共识：代表的是数据的一致性，它意味着即便是在并发、异常等情况下也能达成共识（前提是没有叛徒）


# paxos：

## 具体应用场景：

## 节点角色：

提议者（proposer）：负责提出一个值

接收者（acceptor）：负责选择一个值

学习者（learner）：   负责学习被选中的值

## 核心思想：

通过让 proposer 与大多数 acceptor 提前进行一次交流，让 proposer 感知到当前提出的值是否可能被大多数 acceptor 接收。如果不能被接收，proposer 可以改变策略之后（例如增加提议编号，或接收某一个 proposer 已经提出的值）再继续进行协调，最终让大多数接收者就某一个值达成共识。Paxos 通过一个提议编码保证了后面被接收的值一定是编号更大的值，从而实现了写操作的线性一致性。

## 达成共识过程：

1. 提议者选择一个提议编号 n，并把 prepare 请求发送给大多数接收者；
2. 接收者回复一个大于等于 n 的提议编号；
3. 提议者收到回复，并记录这些回复中最大的提议编号，然后将被选中的值和这个最大的提议编号作为一个 accept 请求，发送给对应的接收者；
4. 如果一个接收者收到一个编号为 n 的 accept 请求，那么除非它已经回复了一个编号比 n 大的 prepare 请求，否则它会接受这个提议；
5. 当接收者接受一个提议后，它会通知所有的 learner 这个提议，最终所有的节点都会就一个节点的提议达成一致。

# Raft 算法：

## 具体应用场景：etcd、tidb、consul、nacos

# 节点角色：

领导者（Leader）：     集群中的管理者，所有client的流量都从leader这里经过；周期性的向follower发出心跳维持统治；当发现自己不是leader的时候会转为follower

候选人（Candidate）：集群的候选者，会发起投票试图当选leader

跟随者（Follower）：   集群中的被管理者，只会对其它服务器的命令做出响应。在长时间得不到leader响应之后会转为candidate

term：在raft协议中实际是作为逻辑时钟，只有处在最新term的服务器和消息才是安全有效的。

# 核心思想：

保证每个节点具有相同的复制日志，进而保证所有节点的最终状态是一致的

# 达成共识过程：


## 选举

节点投票规则：

1. 判断当前的`Term`的和请求投票参数中的`Term`：
    1. 如果当前的`Term` > 请求投票参数中的`Term`，那么拒绝投票（设置`voteGranted`为`false`），并返回当前的`Term`
    2. 否则就更新当前`Term`为请求投票参数中的`Term`， 并将自身状态切换成`Follower`
2. 检测当前节点的投票状态：
    1. 如果当前的节点没有给任何其他节点投过票，或者是已经投过票给当前节点，那么继续检测日志的匹配状态（步骤3）
    2. 否则，那么拒绝投票（设置`voteGranted`为`false`）， 因为一个节点在一个任期内不能同时投票给多个节点
3. 检测候选人的日志是否至少比当前节点的日志新，通过比较候选人的`lastLogIndex`和`lastLogTerm`和当前节点的日志，确保新选举出来的`Leader`不会丢失已经提交的日志：
    1. 如果日志匹配，即当前的任期和候选人的任期相同，且候选人的日志长度比当前的日志长度 **或者** 候选人的任期比比当前节点的任期高，那么就为候选人投票（设置`votedGranted`为`true`），并成为`Follower`
    2. 否则，那么就拒绝投票（设置`voteGranted`为`false`）
 

候选人发起投票过程：

1. 当节点在指定的时间之内没有收到leader或者candidate的有效消息时会发起选举，此时所有
2. 该节点递增自己的term，将自己的状态变为candidate，并1投票给自己
3. 向集群其它节点发起RequestVote投票请求
4. 其他节点收到投票请求时，当前请求包含的term大于等于自身的term且日志信息不旧于candidate的日志信息（还log数据最新），follower投出1票，否则拒绝投票。
5. 如果随机超时时间内，该节点的选举会有下列三种结果：
    1. 自己选举成功。超过集群一半服务器都同意，状态变为leader。新的 Leader 节点就会向其他节点发送 AppendEntries RPC， 确认自己 Leader 的地位，终止选举。
    2. 过程中发现其他节点成为了 Leader 且 Term 比自己的大。（即收到其他节点的 AppendEntries），则会变为 Follower 状态。
    3. 选举超时或者没有节点选举成功。raft使用随机超时时间（random election timeout），确保不会有大量 candidate同时发起选举，在超时之后重试即可重新选举成功。
## 日志复制：

Leader 会将来自客户端的每个请求，转变为状态机将要执行的操作，并包装为一个 Entry 放入到 log 中；通过 AppendEntries发送给其他节点，要求由follower节点把这个 Entry 添加到 log 中。当 Entry 被复制到大多数节点之后，也就是被大部分的节点认可之后，这个 Entry 的状态就变为 Committed。每个follower执行这些committed状态的Entry。

## 异常处理

## 日志压缩

