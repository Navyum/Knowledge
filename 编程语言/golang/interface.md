---
title: interface
author: navyum
date: 2025-06-21 22:24:53

article: true
index: true

headerDepth: 2
sticky: false
star: false

category:
  - ç¬”è®°
tag:
  - ç¬”è®°
---

1. æ¥å£çš„ä½œç”¨ï¼š
    1. éšè—ç»†èŠ‚ï¼šé€šè¿‡æ¥å£å¯ä»¥å¯¹å¯¹è±¡è¿›è¡Œå¿…è¦çš„æŠ½è±¡
    2. è§£è€¦ï¼š      é€šè¿‡æ¥å£ï¼Œæˆ‘ä»¬èƒ½å¤Ÿä»¥æ¨¡å—åŒ–çš„æ–¹å¼æ„å»ºèµ·å¤æ‚ã€åºå¤§çš„ç³»ç»Ÿ
    3. æƒé™æ§åˆ¶ï¼šé€šè¿‡æ¥å£æ¥æ§åˆ¶æ¥å…¥æ–¹å¼å’Œæ¥å…¥æ–¹çš„è¡Œä¸ºï¼Œé™ä½å®‰å…¨é£é™©

2. ä½¿ç”¨æ¥å£çš„æˆæœ¬ï¼š
a. å†…å­˜é€ƒé€¸ï¼šæ¥å£çš„åŠ¨æ€æ•°æ®ç±»å‹å¯¹åº”çš„æ•°æ®å¤§å°éš¾ä»¥é¢„æ–™ï¼Œæ‰€ä»¥æ¥å£ä¸­ä½¿ç”¨æŒ‡é’ˆæ¥å­˜å‚¨æ•°æ®ã€‚ä¸ºäº†æ–¹ä¾¿æ•°æ®è¢«å¯»å€ï¼Œå¹³æ—¶åˆ†é…åœ¨æ ˆä¸­çš„å€¼ä¸€æ—¦èµ‹å€¼ç»™æ¥å£åï¼ŒGo è¿è¡Œæ—¶ä¼šåœ¨å †åŒºä¸ºæ¥å£å¼€è¾Ÿå†…å­˜ï¼ˆå†…å­˜é€ƒé€¸æ„å‘³ç€å †å†…å­˜åˆ†é…æ—¶çš„æ—¶é—´æ¶ˆè€—ï¼‰

b. æŸ¥æ‰¾æ¥å£ä¸­å®¹çº³çš„åŠ¨æ€æ•°æ®ç±»å‹å’Œå®ƒå¯¹åº”çš„æ–¹æ³•çš„æŒ‡é’ˆå¸¦æ¥çš„å¼€é”€

3. å€¼æ¥æ”¶è€…å’ŒæŒ‡é’ˆæ¥æ”¶è€…ï¼š
    1. å®ç°äº†æ¥æ”¶è€…æ˜¯å€¼ç±»å‹çš„æ–¹æ³•ï¼Œä¼šéšå«å®ç°æ¥æ”¶è€…æ˜¯æŒ‡é’ˆç±»å‹çš„æ–¹æ³•ï¼›
    2. å®ç°äº†æ¥æ”¶è€…æ˜¯æŒ‡é’ˆç±»å‹çš„æ–¹æ³•ï¼Œä¸ä¼šè‡ªåŠ¨ç”Ÿæˆå¯¹åº”æ¥æ”¶è€…æ˜¯å€¼ç±»å‹çš„æ–¹æ³•ï¼›
    3. å¯¹äºå®ç°äº†æ¥æ”¶è€…æ˜¯å€¼ç±»å‹çš„æ–¹æ³•ï¼Œæ— è®ºè°ƒç”¨è€…æ˜¯å¯¹è±¡è¿˜æ˜¯å¯¹è±¡æŒ‡é’ˆï¼Œä¿®æ”¹çš„éƒ½æ˜¯å¯¹è±¡çš„å‰¯æœ¬ï¼Œä¸å½±å“è°ƒç”¨è€…ï¼›
    4. å¯¹äºå®ç°äº†æ¥æ”¶è€…æ˜¯æŒ‡é’ˆç±»å‹çš„æ–¹æ³•ï¼Œè°ƒç”¨è€…ä¿®æ”¹çš„æ˜¯æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡æœ¬èº«ï¼›
    5. å¦‚ä½•åŒºåˆ†ä½•æ—¶ä½¿ç”¨ï¼š
        1. ç±»å‹çš„æˆå‘˜éƒ½æ˜¯ç”± Go è¯­è¨€é‡Œå†…ç½®çš„åŸå§‹ç±»å‹ï¼Œå¦‚å­—ç¬¦ä¸²ï¼Œæ•´å‹å€¼ç­‰ï¼Œé‚£å°±å®šä¹‰å€¼æ¥æ”¶è€…ç±»å‹çš„æ–¹æ³•ã€‚ï¼ˆåƒå†…ç½®çš„å¼•ç”¨ç±»å‹ï¼Œå¦‚ sliceï¼Œmapï¼Œinterfaceå£°æ˜ä»–ä»¬çš„æ—¶å€™ï¼Œå®é™…ä¸Šæ˜¯åˆ›å»ºäº†ä¸€ä¸ªÂ `header`ï¼Œ å¯¹äºä»–ä»¬ä¹Ÿæ˜¯ç›´æ¥å®šä¹‰å€¼æ¥æ”¶è€…ç±»å‹çš„æ–¹æ³•ã€‚è¿™æ ·ï¼Œè°ƒç”¨å‡½æ•°æ—¶ï¼Œæ˜¯ç›´æ¥ copy äº†è¿™äº›ç±»å‹çš„Â `header`ï¼Œè€ŒÂ `header`Â æœ¬èº«å°±æ˜¯ä¸ºå¤åˆ¶è®¾è®¡çš„ ï¼‰
        2. å¦‚æœç±»å‹å…·å¤‡éåŸå§‹çš„æœ¬è´¨ï¼Œä¸èƒ½è¢«å®‰å…¨åœ°å¤åˆ¶ï¼Œè¿™ç§ç±»å‹æ€»æ˜¯åº”è¯¥è¢«å…±äº«ï¼Œé‚£å°±å®šä¹‰æŒ‡é’ˆæ¥æ”¶è€…çš„æ–¹æ³•ã€‚æ¯”å¦‚ go æºç é‡Œçš„æ–‡ä»¶ç»“æ„ä½“ï¼ˆstruct Fileï¼‰å°±ä¸åº”è¯¥è¢«å¤åˆ¶ï¼Œåº”è¯¥åªæœ‰ä¸€ä»½`å®ä½“` 

4. ifaceå’ŒefaceäºŒè€…åŒºåˆ«ï¼š
ifaceæè¿°çš„æ¥å£åŒ…å«æ–¹æ³•ï¼Œè€ŒÂ efaceåˆ™æ˜¯ä¸åŒ…å«ä»»ä½•æ–¹æ³•çš„ç©ºæ¥å£: interface{}

5. ifaceç»“æ„ä½“è¯´æ˜:
```plain
type iface struct {
	tab  *itab    //æ¥å£çš„ç±»å‹ä»¥åŠèµ‹ç»™è¿™ä¸ªæ¥å£çš„å®ä½“ç±»å‹
	data unsafe.Pointer //æŒ‡å‘æ¥å£å…·ä½“çš„å€¼ï¼Œä¸€èˆ¬è€Œè¨€æ˜¯ä¸€ä¸ªæŒ‡å‘å †å†…å­˜çš„æŒ‡é’ˆ
}

type itab struct {
	inter  *interfacetype //æè¿°äº†æ¥å£çš„ç±»å‹
	_type  *_type //æè¿°äº†å®ä½“çš„ç±»å‹ï¼ŒåŒ…æ‹¬å†…å­˜å¯¹é½æ–¹å¼ï¼Œå¤§å°ç­‰
	link   *itab
	hash   uint32 // copy of _type.hash. Used for type switches.
	bad    bool   // type does not implement interface
	inhash bool   // has this itab been added to hash?
	unused [2]byte
	fun    [1]uintptr // variable sized æ”¾ç½®å’Œæ¥å£æ–¹æ³•å¯¹åº”çš„å…·ä½“æ•°æ®ç±»å‹çš„æ–¹æ³•åœ°å€
}

type interfacetype struct {
	typ     _type //æè¿° Go è¯­è¨€ä¸­å„ç§æ•°æ®ç±»å‹çš„ç»“æ„ä½“
	pkgpath name //å®šä¹‰äº†æ¥å£çš„åŒ…å
	mhdr    []imethod  //æ¥å£æ‰€å®šä¹‰çš„å‡½æ•°åˆ—è¡¨
}
```

5.  ifaceå†…å­˜æ¨¡å‹ï¼š
![å›¾ç‰‡](https://raw.staticdn.net/Navyum/imgbed/pic/IMG/ea9c54d9bf3b37ad38aa5543368ad439.png)



6. efaceç»“æ„ä½“ï¼š
```plain
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
```

7. æ¥å£çš„åŠ¨æ€ç±»å‹å’ŒåŠ¨æ€å€¼ï¼š
`tab`Â æ˜¯æ¥å£è¡¨æŒ‡é’ˆæŒ‡å‘ç±»å‹ä¿¡æ¯ï¼Œå³åŠ¨æ€ç±»å‹ã€‚

`data`Â æ˜¯æ•°æ®æŒ‡é’ˆæŒ‡å‘å…·ä½“çš„æ•°æ®ï¼Œå³åŠ¨æ€å€¼ã€‚

1. _typeç»“æ„ä½“:
```plain
type _type struct {
    // ç±»å‹å¤§å°
	size       uintptr
    ptrdata    uintptr
    // ç±»å‹çš„ hash å€¼
    hash       uint32
    // ç±»å‹çš„ flagï¼Œå’Œåå°„ç›¸å…³
    tflag      tflag
    // å†…å­˜å¯¹é½ç›¸å…³
    align      uint8
    fieldalign uint8
    // ç±»å‹çš„ç¼–å·ï¼Œæœ‰bool, slice, struct ç­‰ç­‰ç­‰ç­‰
	kind       uint8
	alg        *typeAlg
	// gc ç›¸å…³
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
```

8. Go è¯­è¨€å„ç§æ•°æ®ç±»å‹éƒ½æ˜¯åœ¨Â `_type`Â å­—æ®µçš„åŸºç¡€ä¸Šï¼Œå¢åŠ ä¸€äº›é¢å¤–çš„å­—æ®µæ¥è¿›è¡Œç®¡ç†çš„ã€‚
```plain
type arraytype struct {
	typ   _type
	elem  *_type
	slice *_type
	len   uintptr
}
type chantype struct {
	typ  _type
	elem *_type
	dir  uintptr
}
type slicetype struct {
	typ  _type
	elem *_type
}
type structtype struct {
	typ     _type
	pkgPath name
	fields  []structfield
}
```

9. æ¥å£çš„æ„é€ è¿‡ç¨‹ï¼š
10. æ¥å£è½¬æ¢çš„åŸç†ï¼š
    1. å½“åˆ¤å®šä¸€ç§ç±»å‹æ˜¯å¦æ»¡è¶³æŸä¸ªæ¥å£æ—¶ï¼ŒGo ä½¿ç”¨ç±»å‹çš„æ–¹æ³•é›†å’Œæ¥å£æ‰€éœ€è¦çš„æ–¹æ³•é›†è¿›è¡ŒåŒ¹é…ï¼Œå¦‚æœç±»å‹çš„æ–¹æ³•é›†å®Œå…¨åŒ…å«æ¥å£çš„æ–¹æ³•é›†ï¼Œåˆ™å¯è®¤ä¸ºè¯¥ç±»å‹å®ç°äº†è¯¥æ¥å£(duck typing ğŸ¦†ç±»å‹)
        1. åŒ¹é…çš„ç»†èŠ‚ï¼šæŸç±»å‹æœ‰Â `m`Â ä¸ªæ–¹æ³•ï¼ŒæŸæ¥å£æœ‰Â `n`Â ä¸ªæ–¹æ³•ï¼Œåˆ™å¾ˆå®¹æ˜“çŸ¥é“è¿™ç§åˆ¤å®šçš„æ—¶é—´å¤æ‚åº¦ä¸ºÂ `O(mn)`ï¼ŒGo ä¼šå¯¹æ–¹æ³•é›†çš„å‡½æ•°æŒ‰ç…§å‡½æ•°åçš„å­—å…¸åºè¿›è¡Œæ’åºï¼Œæ‰€ä»¥å®é™…çš„æ—¶é—´å¤æ‚åº¦ä¸ºÂ `O(m+n)` 
    2. å…·ä½“ä»£ç å®ç°ï¼š
```plain
func convI2I(inter *interfacetype, i iface) (r iface) {
	tab := i.tab
	if tab == nil {
		return
	}
	if tab.inter == inter {
		r.tab = tab
		r.data = i.data
		return
	}
	r.tab = getitab(inter, tab._type, false)
	r.data = i.data
	return
}
```
å‡½æ•°å‚æ•°Â `inter`Â è¡¨ç¤ºæ¥å£ç±»å‹ï¼Œ`i`Â è¡¨ç¤ºç»‘å®šäº†å®ä½“ç±»å‹çš„æ¥å£ï¼Œ`r`Â åˆ™è¡¨ç¤ºæ¥å£è½¬æ¢äº†ä¹‹åçš„æ–°çš„Â `iface`ã€‚Â `iface`Â æ˜¯ç”±Â `tab`Â å’ŒÂ `data`Â ä¸¤ä¸ªå­—æ®µç»„æˆã€‚æ‰€ä»¥Â `convI2I`Â å‡½æ•°éœ€è¦æ‰¾åˆ°æ–°Â `interface`Â çš„Â `tab`Â å’ŒÂ `dataã€‚`
æˆ‘ä»¬è¿˜çŸ¥é“ï¼Œ`tab`Â æ˜¯ç”±æ¥å£ç±»å‹Â `interfacetype`Â å’Œ å®ä½“ç±»å‹Â `_type`ã€‚æ‰€ä»¥æœ€å…³é”®çš„è¯­å¥æ˜¯Â `r.tab = getitab(inter, tab._type, false)` 

```plain
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
	// â€¦â€¦
    // æ ¹æ® inter, typ è®¡ç®—å‡º hash å€¼
	h := itabhash(inter, typ)
	// look twice - once without lock, once with.
	// common case will be no lock contention.
	var m *itab
	var locked int
	for locked = 0; locked < 2; locked++ {
		if locked != 0 {
			lock(&ifaceLock)
        }
        
        // éå†å“ˆå¸Œè¡¨çš„ä¸€ä¸ª slot
		for m = (*itab)(atomic.Loadp(unsafe.Pointer(&hash[h]))); m != nil; m = m.link {
            // å¦‚æœåœ¨ hash è¡¨ä¸­å·²ç»æ‰¾åˆ°äº† itabï¼ˆinter å’Œ typ æŒ‡é’ˆéƒ½ç›¸åŒï¼‰
			if m.inter == inter && m._type == typ {
                // â€¦â€¦
                
				if locked != 0 {
					unlock(&ifaceLock)
				}
				return m
			}
		}
	}
    // åœ¨ hash è¡¨ä¸­æ²¡æœ‰æ‰¾åˆ° itabï¼Œé‚£ä¹ˆæ–°ç”Ÿæˆä¸€ä¸ª itab
	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))
	m.inter = inter
    m._type = typ
    
    // æ·»åŠ åˆ°å…¨å±€çš„ hash è¡¨ä¸­
	additab(m, true, canfail)
	unlock(&ifaceLock)
	if m.bad {
		return nil
	}
	return m
}
```

getitab å‡½æ•°ä¼šæ ¹æ®Â `interfacetype`Â å’ŒÂ `_type`Â å»å…¨å±€çš„ itab å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœèƒ½æ‰¾åˆ°ï¼Œåˆ™ç›´æ¥è¿”å›ï¼›å¦åˆ™ï¼Œä¼šæ ¹æ®ç»™å®šçš„Â `interfacetype`Â å’ŒÂ `_type`Â æ–°ç”Ÿæˆä¸€ä¸ªÂ `itab`ï¼Œå¹¶æ’å…¥åˆ° itab å“ˆå¸Œè¡¨ï¼Œè¿™æ ·ä¸‹ä¸€æ¬¡å°±å¯ä»¥ç›´æ¥æ‹¿åˆ°Â `itab`ã€‚

è¿™é‡ŒæŸ¥æ‰¾äº†ä¸¤æ¬¡ï¼Œå¹¶ä¸”ç¬¬äºŒæ¬¡ä¸Šé”äº†ï¼Œè¿™æ˜¯å› ä¸ºå¦‚æœç¬¬ä¸€æ¬¡æ²¡æ‰¾åˆ°ï¼Œåœ¨ç¬¬äºŒæ¬¡ä»ç„¶æ²¡æœ‰æ‰¾åˆ°ç›¸åº”çš„Â `itab`Â çš„æƒ…å†µä¸‹ï¼Œéœ€è¦æ–°ç”Ÿæˆä¸€ä¸ªï¼Œå¹¶ä¸”å†™å…¥å“ˆå¸Œè¡¨ï¼Œå› æ­¤éœ€è¦åŠ é”ã€‚è¿™æ ·ï¼Œå…¶ä»–åç¨‹åœ¨æŸ¥æ‰¾ç›¸åŒçš„Â `itab`Â å¹¶ä¸”ä¹Ÿæ²¡æœ‰æ‰¾åˆ°æ—¶ï¼Œç¬¬äºŒæ¬¡æŸ¥æ‰¾æ—¶ï¼Œä¼šè¢«æŒ‚ä½ï¼Œä¹‹åï¼Œå°±ä¼šæŸ¥åˆ°ç¬¬ä¸€ä¸ªåç¨‹å†™å…¥å“ˆå¸Œè¡¨çš„Â `itab` ã€‚

```plain
// æ£€æŸ¥ _type æ˜¯å¦ç¬¦åˆ interface_type å¹¶ä¸”åˆ›å»ºå¯¹åº”çš„ itab ç»“æ„ä½“ å°†å…¶æ”¾åˆ° hash è¡¨ä¸­
func additab(m *itab, locked, canfail bool) {
	inter := m.inter
	typ := m._type
	x := typ.uncommon()

	// both inter and typ have method sorted by name,
	// and interface names are unique,
	// so can iterate over both in lock step;
    // the loop is O(ni+nt) not O(ni*nt).
    // 
    // inter å’Œ typ çš„æ–¹æ³•éƒ½æŒ‰æ–¹æ³•åç§°è¿›è¡Œäº†æ’åº
    // å¹¶ä¸”æ–¹æ³•åéƒ½æ˜¯å”¯ä¸€çš„ã€‚æ‰€ä»¥å¾ªç¯çš„æ¬¡æ•°æ˜¯å›ºå®šçš„
    // åªç”¨å¾ªç¯ O(ni+nt)ï¼Œè€Œé O(ni*nt)
	ni := len(inter.mhdr)
	nt := int(x.mcount)
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
	j := 0
	for k := 0; k < ni; k++ {
		i := &inter.mhdr[k]
		itype := inter.typ.typeOff(i.ityp)
		name := inter.typ.nameOff(i.name)
		iname := name.name()
		ipkg := name.pkgPath()
		if ipkg == "" {
			ipkg = inter.pkgpath.name()
		}
		for ; j < nt; j++ {
			t := &xmhdr[j]
            tname := typ.nameOff(t.name)
            // æ£€æŸ¥æ–¹æ³•åå­—æ˜¯å¦ä¸€è‡´
			if typ.typeOff(t.mtyp) == itype && tname.name() == iname {
				pkgPath := tname.pkgPath()
				if pkgPath == "" {
					pkgPath = typ.nameOff(x.pkgpath).name()
				}
				if tname.isExported() || pkgPath == ipkg {
					if m != nil {
                        // è·å–å‡½æ•°åœ°å€ï¼Œå¹¶åŠ å…¥åˆ°itab.funæ•°ç»„ä¸­
						ifn := typ.textOff(t.ifn)
						*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
					}
					goto nextimethod
				}
			}
		}
        // â€¦â€¦
        
		m.bad = true
		break
	nextimethod:
	}
	if !locked {
		throw("invalid itab locking")
    }

    // è®¡ç®— hash å€¼
    h := itabhash(inter, typ)
    // åŠ åˆ°Hash Sloté“¾è¡¨ä¸­
	m.link = hash[h]
	m.inhash = true
	atomicstorep(unsafe.Pointer(&hash[h]), unsafe.Pointer(m))
}
```
 `additab`Â ä¼šæ£€æŸ¥Â `itab`Â æŒæœ‰çš„Â `interfacetype`Â å’ŒÂ `_type`Â æ˜¯å¦ç¬¦åˆï¼Œå°±æ˜¯çœ‹Â `_type`Â æ˜¯å¦å®Œå…¨å®ç°äº†Â `interfacetype`Â çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯çœ‹ä¸¤è€…çš„æ–¹æ³•åˆ—è¡¨é‡å çš„éƒ¨åˆ†å°±æ˜¯Â `interfacetype`Â æ‰€æŒæœ‰çš„æ–¹æ³•åˆ—è¡¨ã€‚æ³¨æ„åˆ°å…¶ä¸­æœ‰ä¸€ä¸ªåŒå±‚å¾ªç¯ï¼Œä¹ä¸€çœ‹ï¼Œå¾ªç¯æ¬¡æ•°æ˜¯Â `ni * nt`ï¼Œä½†ç”±äºä¸¤è€…çš„å‡½æ•°åˆ—è¡¨éƒ½æŒ‰ç…§å‡½æ•°åç§°è¿›è¡Œäº†æ’åºï¼Œå› æ­¤æœ€ç»ˆåªæ‰§è¡Œäº†Â `ni + nt`Â æ¬¡ï¼Œä»£ç é‡Œé€šè¿‡ä¸€ä¸ªå°æŠ€å·§æ¥å®ç°ï¼šç¬¬äºŒå±‚å¾ªç¯å¹¶æ²¡æœ‰ä» 0 å¼€å§‹è®¡æ•°ï¼Œè€Œæ˜¯ä»ä¸Šä¸€æ¬¡éå†åˆ°çš„ä½ç½®å¼€å§‹ã€‚ 
