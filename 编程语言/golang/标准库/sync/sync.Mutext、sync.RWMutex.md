---
title: sync.Mutext、sync.RWMutex
author: navyum
date: 2025-06-21 22:29:00

article: true
index: true

headerDepth: 2
sticky: false
star: false

category:
  - 笔记
tag:

  - 笔记
---

Mutex定义：

    互斥锁看作是针对某一个临界区或某一组相关临界区的唯一访问令牌

    互斥锁一个结构体类型，属于值类型中的一种.

   互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）

Mutex使用注意事项: 

* 不要重复锁定互斥锁；
* 不要忘记解锁互斥锁，必要时使用defer语句；
* 不要对尚未锁定或者已解锁的互斥锁解锁；
* 不要在多个函数之间直接传递互斥锁。
对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine 的。这个 goroutine 所执行的流程，会一直停滞在调用该互斥锁的Lock方法的那行代码上。直到该互斥锁的Unlock方法被调用

最佳实践：

如果一个流程在锁定了某个互斥锁之后分叉了，或者有被中断的可能，那么就应该使用defer语句来对它进行解锁，而且这样的defer语句应该紧跟在锁定操作之后。这是最保险的一种做法。

把互斥锁传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。并且，原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁，所以应该传其指针类型


RWMutex规则：

* 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的 goroutine。
* 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的 goroutine。
* 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的 goroutine。
* 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的 goroutine。
即对于读锁，可以重复锁定读锁，从而不影响访问临界区资源。多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。

对写锁进行解锁，会唤醒“所有因试图锁定读锁，而被阻塞的 goroutine”，并且，这通常会使它们都成功完成对读锁的锁定。

对读锁进行解锁，且需要解锁所有读锁(只会在没有其他读锁锁定的前提下)，才会唤醒“因试图锁定写锁，而被阻塞的 goroutine”；并且，最终只会有一个被唤醒的 goroutine 能够成功完成对写锁的锁定，其他的 goroutine 还要在原处继续等待。至于是哪一个 goroutine，那就要看谁的等待时间最长了。

